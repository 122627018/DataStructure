##5_1 递归
 - 在定义一个过程或函数时出现调用本过程或本函数的成分，称为递归。
 - 若调用自身，称为直接递归。若过程或函数p调用过程或函数q，而q又调用p，称为间接递归
 - 递归算法通常把一个大的复杂问题层层转化为一个或多个与原问题相似的规模较小的问题来求解，只需要少量的代码就可以描述出解题过程所需要的多次重复计算
 - 何时使用递归?1.定义是递归的2.数据结构是递归的3.问题的求解方法是递归的

###Hanoi问题
有些问题的解法是递归的，典型的由Hanoi问题，该问题的描述是：设有3个分别命名为x,y,z的塔座，在塔座x上由n个直径各不相同，从小到大依次编号为1,2，....n的盘片，现要求将x塔座上的n个盘片移到塔座z上并仍按照同样顺序叠放，(规则略)。设计递归求解算法
##5_2 递归调用的实现原理

- 递归调用是函数嵌套调用的一种特殊情况，即它是调用自身代码
- 这些调用在内部实现时，并不是每次调用真的去复制一个复制件存放在内存中，而是采用代码共享的方式，也就是说它们都是调用同一个函数的代码，而系统每一次开辟一组存储单元，用来存放本次调用的返回地址以及被中断的函数的参量值。这些单元以栈的形式存放，每调用一次就进栈一次，当返回时执行出栈操作操作，把当前栈顶保留的值送回相应的参量中进行恢复，并按栈顶中的返回地址，从断点继续执行
- 每递归调用一次，就需进栈一次，进栈次数称为递归深度，当n越大，递归深度越大，开辟的栈空间也越大
- 算法执行中最长的递归调用的链的长度称为该算法的递归调用深度。
	 
##5_3 递归算法的设计
理论性的说法参考p127
这里讲讲例子，例如**采用递归算法求实数数组A[0..n-1]中的最小值**
思路：如果利用递归的思路来，可以把当前n与(n-1)项做比较，也就是说每次的递归中都只比较俩个数，就是Min(n,(n-1)).那么当n=1的时候，返回n就行了

```
double f(float A[],int i)
{
	double m;
	if(i == 0)
		return A[0];
	else
	{
		m = f(A,i-1);
		if(m>A[i])
			return A[i];
		else
			return (m);
	}	
}
```
###例 5_2 利用串的基本运算写出对串求逆的递归算法
思路：假如我们现在拿到一串字符串，要求逆，我们按照递归的想法来，肯定涉及n与n-1的递归关系链，那么可以这样来，把字符串分成俩串，分别是第1个字符和后面(2,3,....,n)的字符。那么每次都把这俩个交换位置。这样就实现了递归了

```
SqString invert(SqString &s)
{
	SqString s1,s2;
	int t = StrLength(s);
	if(t>0)
	{
		//s1先取出最后一个字符？错误！应该先取出前n-1个字符组成的字符串，然后s2把s1和s的第一个字符拼接起来
		//invert(SubStr(s,2,t-1))可以想象成把后面的已经拼接好了
		s1 = invert(SubStr(s,2,t-1));
		//完成拼接工作
		s2 = Concat(s1,SubStr(s,1,1)); 
	}
	else
		StrCopy(s2,s)
	return s2;
}
```
##5_3_2 递归数据结构的递归算法设计

 - 采用递归方式定义的数据结构称为递归数据结构
 
###例5_4 假设有一个不带头节点的单链表L,设计一个算法释放其中所有节点
思路:设f(L)的功能是释放$a_1$到$a_n$的所有节点，则f(L->next)的功能是释放$a_2到a_n$的所有节点。假设f(L->next)是可实现的，则f(L)的功能是先调用f(L->next)，然后释放L所指节点(课本里的说法，觉得讲得很好)

```
void release(LinkList * L)
{
	if(L!=NULL)
	{
		release(L->next);
		free(L);
	}
}
```
没错算法就是这么简单，之所以写出来是觉得对理解递归非常非常有效果
## 5_3_3 递归求解方法的递归算法设计
对于采用递归方法求解的问题，需要对问题本身进行分析，确定大，小问题解之间的关系，构造合理的递归体。

####例5_5 采用递归算法求解迷宫问题，并输出从入口到出口的所有迷宫路径
思路：说简单其实很简单，说难其实也挺难的。如果没有前面栈和队列对迷宫的求解建议先回去看看。用递归来求解迷宫问题，其实原理跟栈一样,在上面一节也提到了递归的原理其实就是每一个子调用都推进栈里，那么在使用递归方法走迷宫的过程中，就是每走一格，都会把这一格的信息推进栈里。
比如我现在走到a格，好，接着走a格的右边b格，然后发现b格没路，那么此次函数调用完成，返回到走a格的那次递归中。其实也就是栈的实现原理。继续下去说多一下，那要是b格有路呢？继续先走b格的右边c，发现c是墙，好，走b格的下边，发现已经是终点，所以只需要输出path中的格子就行(表达能力比较差，说的比较抽象哈)

```
typedef struct
{
	int i;
	int j;
}Box;
typedef struct
{
	Box data[MaxSize];
	int length;
}PathType;
void mgpath(int xi,int yi,int xe,int ye,PathType path)
{
	int di,k,i,j;
	if(xi == xe && yi == ye)
	{
		path.data[path.length].i = xi;
		path.data[path.length].j = yi;
		path.length++;
		for(k=0;k<path.length;k++)
		{
			printf("\t(%d,%d)",path.data[k].i,path.data[k].j);
			if((k+1)%5 == 0)
				printf("\n");
		}
 	}
 	else
 	{
	 	if(mg[xi][yi] == 0)
	 	{
		 	di = 0;
		 	path.data[path.length].i = xi;
		 	path.data[path.length].j = yi;
		 	path.length++;
		 	while(di<4)
		 	{
			 	switch(di)
			 	{
				 	case 0:
					 	i=略;j=略;
					 	break;
					case 1:
						i=略;j=略;
						 break;
					case 2:
						i=略;j=略;
						break;
					case 3:
						i=略;j=略;
						break;
			 	}
			 	mg[i][j] = -1;
			 	mgpath(i,j,xe,ye,path);
			 	mg[i][j] = 0;
			 	path.length--;
			 	di++;
		 	}
	 	}
 	}
}
```
##练习题
###5_1 已知A[n]为整数数组，编写一个递归算法求其中n个元素的平均值
详细解释看代码
```
float avg(int A[],int n)
{
	if(n == 0)
		return A[0];
	else
		//这一句可能有点难理解，就是因为avg(A,n-1)其实里面是n个元素的平均值，所以avg(A,i)其实是求i+1个元素的平均值
		return ((avg(A,n-1)*n +A[n])/n+1);
}
```
所以求n个元素的平均值：avg(A,n-1);

###5_2 有一个不带表头节点的单链表,其节点类型如下：

```
typedef int ElemType;
typedef struct node
{
	ElemType data;
	struct node * next;
}Node;
```
设计如下递归算法：

 1. 求以h为头指针的单链表的表头个数
 2. 正向显示以h为头指针的单链表的所有节点值
 3. 反向显示以h为头指针的单链表的所有节点值
 4. 删除以h为头指针的单链表中值为x的第一个节点
 5. 删除以h为头指针的单链表中值为x的所有节点值
 6. 输出以h为头指针的单链表中最大节点值
 7. 输出以h为头指针的单链表中最小节点值


----------
待续(今天去游泳，明天再写了)
