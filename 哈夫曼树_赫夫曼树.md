# 前言
可能有的人只是进来看看哈夫曼树是什么？哈夫曼树有什么用？说白了，哈夫曼树就是最优二叉树，如果你又想问什么是最优二叉树，那你真的要继续看下去了哈。那么哈夫曼树有什么用呢？用最俗的说法比如现在我们有一串数据，这串数据存储在计算机中肯定是使用二进制编码，当我们要使用的时候就从里面遍历取出数据，那么哈夫曼树扮演的角色就是把最常用的放在前面，最少用到的放到后面，最常用到的那个数据编码长度是最短的，最少用到的那个编码长度相对于前面的比较长，所以这样大大节省了空间，所以哈夫曼树一种最常用的应用就是数据压缩
# 概述
在很多应用中，常常将树的节点赋上一个有着某种意义的数值，称此数值为该节点的**权**。可以把权理解为重量，或者出现的次数，很多种理解方式，就是它的地位的意思。那么从根节点到某节点的路径长度与该节点上权值的乘积称为该节点的**带权路径长度**。
在所有二叉树中，带权路径长度最小的二叉树称之为**最优二叉树**，也叫**哈夫曼树**。

# 构造一棵哈夫曼树
哈夫曼树的构造算法是这样的：给我们n个有权值的节点，要我们构造成一棵带有n个叶子节点的哈夫曼树。其实，我们可以这样理解，给我们一串字符串，然后每个字符出现的次数为权值，要求我们构造一棵关于这个字符串的一棵哈夫曼树。
那么我们的思路是：

 1. 先选取俩个节点权值最小的子树分别作为左，右子树构造一棵新的二叉树，然后置新的二叉树的根节点的权值为其左右子树的根节点的权值之和。
 2. 然后1中新构成的二叉树再跟另外一个权值最小的节点又新构成一棵二叉树。
 3. 重复2,3步骤，直到只剩一棵树，这棵树就是哈夫曼树。

(个人理解用语言描述得可能不是很准确，建议直接网上找动图看过程比较容易理解)
那么哈夫曼树的构造方法是用一个**ht[]数组**存放哈夫曼树的每个节点，对于具有n个叶子节点的哈夫曼树，总共有2n-1个节点
先看看哈夫曼树中每个节点类型：
```
typedef struct
{
	char data;
	double weight;   //权值
	int parent;      //双亲节点
	int lchild;      //左孩子节点
	int rchild;      //右孩子节点
}
```
算法的思路是：
![这里写图片描述](http://img.blog.csdn.net/20160701135022159)
(自己画的图，不要吐槽)
先令所有节点的parent，lchild和rchild置为初值-1，然后第一次先令非叶子节点i等于前n个叶子节点中最小的俩个之和，依次下去，i++；在每次循环之后，非叶子节点i都会列入下次循环中节点大小的判断。

```
//取出前i-1位中最小的俩位，用lnode个rnode分别记录位置
for(k=0;k<i-1;k++)
{
	if(ht[k].praent == -1)
	{
		if(hk[k].weight<min1)
		{
			min2 = min1;rnode = lnode;
			min1 = ht[k].weight;lnode = k;
		}
		else if(ht[k].weight<min2)
		{
			min2 = ht[k].weight;
			rnode = k;
		}
	}
}
```
上面的方法取出前i-1位中权值最小的俩位，那么接下来我们要做的就是令第i位的权值为这俩个最小位的权值之和，然后使这俩个最小位的parent为i，i的左右孩子分别为lnode和rnode，那么哈夫曼树的构造算法就是：
```
void CreateHT(HTNode ht[],int n)
{
	int i,j,k,lnode,rlode;
	double min1,min2;
	//进行初始化
	for(i=0;i<2*n-1;i++)
		hi[i].parent = h[i].lchild = h[i].rchild = -1;
	for(i=n;i<2n-1;i++)
	{
		min1 = min2 = 32767;
		lnode = rlode = -1;
		for(k=0;k<i-1;k++)
		{
			if(ht[k].praent == -1)
			{
				if(hk[k].weight<min1)
				{
					min2 = min1;rnode = lnode;
					min1 = ht[k].weight;lnode = k;
				}
				else if(ht[k].weight<min2)
				{
					min2 = ht[k].weight;
					rnode = k;
				}
			}
			ht[i].weight = ht[lnode].weight+ht[rnode].weight;
			ht[i].lchild = lnode;ht[i].rchild = rnode;
			ht[lnode].parent = i;ht[rnode].parent = i;
		}
	}
}
```

后面有时间再补充说以下哈夫曼树的实际应用
